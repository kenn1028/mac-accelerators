# mac-accelerators
GitHub Repository for a BS Computer Engineering Undergraduate Project:\
"_Comparative Analysis and Implementation of Energy-Quality Scalable Multiply-Accumulate Architectures for TinyML Applications_" 

Author: PELAYO, Kenn Danielle C.\
School: University of the Philippines - Diliman, BS Computer Engineering
Publication: https://ieeexplore.ieee.org/document/10848625

Feel free to contact me at _kenn.pelayo@eee.upd.edu.ph_

# Benchmarking Workflow

The MAC unit architectures are benchmarked by performing **10,000 MAC operations per precision mode (2bx2b, 4bx4b, 8bx8b)** using Python Scripts to overwrite the _CLK_PERIOD_ in the SystemVerilog testbenches as well as the TCL scripts when calling Synopsys PrimeTime (PT) for static power analysis at different operating frequencies. The Python scripts would then create respective CSV files containing the Area/Slack reports and Energy per Operation/Throughput per Area reports across these varying frequencies. The general behavior of the Python scripts can be visualized as follows:

![Benchmarking Workflow](https://github.com/kenn1028/mac-accelerators/blob/main/.images/1_benchmarking_flow.png?raw=true)

To benchmark a specific design, we use the following steps:

1. Make sure to run ``source ../set_synopsys.sh`` if you're within the directory of the desired MAC unit architecture. This ensures that the console has access to Synopsys Design Tools such as DC for synthesis, VCS for simulation, and PT for power analysis.

2. In the ``slack_frequency_sweep.py`` of their respective directory, you can set the _FREQUENCY_ range that you want to sweep by editing the starting and ending frequency as well as the interval or increment between each step. This Python script outputs ``slack_synthesis_reports.csv`` that would resynthesize the design by editing the frequency constraints of the ``cons/timing.sdc`` file based on the set frequency range. This script reports the _Area_ of the MAC unit as well as the _Slack_ and looks for the optimal frequency constraint (resulting in a Slack almost equal to 0) to ensure that we have synthesized the most optimized version of our design.

3. Wait depending on the amount of frequencies that you set. The larger the amount, the longer it takes unless you start at a frequency where that slack is already low in the first place. Area/Slack results would be logged in ``slack_synthesis_reports.csv``.

4. Copy the _Total Fusion Unit Area_ (in um^2) reported by the ``slack_synthesis_reports.csv`` into the ``sim/pt_frequency_sweep.py`` script to ensure that it calculates the Throughput per Area (GOPs/mm^2) correctly.

5. Before running ``sim/pt_frequency_sweep.py`` ensure that the _end_freq_ or ending frequency of the Python script ends at the **same frequency** as the frequency constraints used when synthesizing the optimized design by looking at the ``slack_synthesis_reports.csv`` file. This ensures that when sweeping the frequency in the optimized design, it does not operate _faster_ than what it was synthesized for and that it properly works.

6. Wait again until all the precision modes have been benchmarked. Energy/Operation and Throughput/Area reports would be logged in ``slack_synthesis_reports.csv``.

# Test Case Generation and Testbench Runtime Output Validation

The input activations and weights are generated by the ``sim/generate_test_files.py`` Python Script. The code block I.b in the Python script allows you to sample the probability distribution of a NumPy file and generate input weights similar to a target DNN model, otherwise you can generate random 8-bit inputs with a Gaussian probability distribution. This script generates a _.txt_ file containing 8-bit inputs that the SystemVerilog testbench would read as well as generate output _.txt_ files calculating the expected outputs by the MAC operation/s for each precision mode. These output text files would also be read by the SystemVerilog testbench during runtime to validate the output of the MAC operation when simulated using Synopsys VCS.

![Test Case Generation Workflow](https://github.com/kenn1028/mac-accelerators/blob/main/.images/2_testcase_gen_valid_flow.png?raw=true)

The behavior of the ``sim/generate_test_files.py`` Python Script is shown in the figure above. It takes multiple input parameters such as the architecture (output-combined or output-separate), whether or not the design is the baseline/data-gated, whether or not we would also generate output validation files for asymmetric precision modes, etc.

# Manual Synopsys DC Synthesis, VCS Simulation, PT Power Analysis Workflow

If you want to synthesize the design, run the SystemVerilog testbench, or perform power analysis manually without using the Python automation scripts, you can perform the following steps:

1. While inside the design directory (while ensuring that the directory hierarchy follows ``directory_template`` with the TCL scripts and constraints file), run: ``source ../set_synopsys.sh``

2. **To synthesize using Synopsys DC**, run: ``dc_shell -f compile.tcl -output_log_file logs/compile.log``

3. Move into the ``\sim`` directory.

4. **To simulate the testbench using Synopsys VCS**, run: ``vcs mac_engine_tb.sv ../mapped/mac_engine_mapped.v /cad/tools/libraries/dwc_logic_in_gf22fdx_sc7p5t_116cpp_base_csc20l/GF22FDX_SC7P5T_116CPP_BASE_CSC20L_FDK_RELV02R80/model/verilog/GF22FDX_SC7P5T_116CPP_BASE_CSC20L.v /cad/tools/libraries/dwc_logic_in_gf22fdx_sc7p5t_116cpp_base_csc20l/GF22FDX_SC7P5T_116CPP_BASE_CSC20L_FDK_RELV02R80/model/verilog/prim.v -full64 -debug_pp +neg_tchk -R -l vcs.log`` which would generate the area, timing, and constraints reports in the sub-directory``mac_design/logs``.

5. (Optionally) You can view the waveforms through Synopsys DVE by running: ``dve -full64 &``, then load the _.vpd_ file which allows you to "Add to Waves" of the signals that you're interested in viewing. You can also load the session saved in the repository: ``session.mac_engine_tb.vpd.tcl`` to see a more organized view of the signals that we're interested in.

6. **To perform static power analysis using Synopsys PT**, run: ``pt_shell`` then, while making sure that you're in the same directory as the TCL script, run ``source power.tcl`` which would generate a ``mac_engine_pt_power.rpt`` file containing the results.
